OverallPrettyNormalPassword
\chapter{Systemy operacyjne}
\PartialToc
%\startcontents[chapters]
%\printcontents[chapters]{}{1}{\section*{\contentsname}}
\section{EKK\_IT1A\_W06}
\textbf{231. Która odpowiedź odnosi się do pamięci asocjacyjnej}

\vspace{0.4cm}

Odpowiedź: dane są udostępniane sekwencyjnie (FAŁSZ)


Asocjacja (łac. accociatio – połączenie) – proces skojarzenia co najmniej dwóch zjawisk psychicznych tak, by pojawienie się jednego z nich spowodowało tendencję do występowania pozostałych

Wyjaśnienie:
Pamięć asocjacyjna, nazywana również pamięcią skojarzeniową jest pamięcią umożliwiającą jednoczesne wyszukiwanie zadanego wzorca we wszystkich swoich komórkach.
Pamięć asocjacyjna to pamięć adresowana zawartością, w której dostęp do zapisanych danych uzyskuje się przez podanie zawartości szukanej komórki pamięci - całej lub wybranych bitów.
Pamięć wyszukuje wszystkie komórki, których zawartość jest zgodna z wzorcem wpisanym do rejestru adresu (jest badana tylko zgodność bitów wskazanych w rejestrze maski)
i ustawia znaczniki w rejestrze zgodności. Znaczniki te wskazują szukane komórki pamięci, których zawartość może być teraz odczytana.
Porównywanie zawartości wszystkich komórek z wzorcem odbywa się równocześnie, ponieważ z każdą komórką jest związany oddzielny komparator.
Pamięć skojarzeniowa jest droga, niewielkie jej moduły stosuje się do budowy pamięci podręcznych i sprzętu stronicującego.
Główną wadą odwzorowywania skojarzeniowego są złożone układy wymagane do równoległego badania znaczników wszystkich wierszy pamięci podręcznej.


Odwzorowywanie sekcyjno-skojarzeniowe stanowi kompromis łączący zalety odwzorowywania bezpośredniego i skojarzeniowego.
Więcej na: 	\url{http://kik.pcz.pl/soold/mainpage/subject22_2/chapt2.html}



\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{232. Dla uniknięcia błędów uwarunkowanych czasowo, maksymalna liczba procesów które mogą znajdować się wewnątrz sekcji krytycznej wynosi}

\vspace{0.4cm}

Odpowiedź: 16 (FAŁSZ)
		poprawna: 1

Wyjaśnienie: Każdy proces ma segment kodu zwany sekcja krytyczną (ang. critical section), w którym może zmieniać wspólne zmienne, aktualizować tablice, pisać do pliku itd.
Ważną cechą tego systemu jest to, że kiedy jeden proces wykonuje sekcję krytyczną, wówczas \textbf{żaden inny proces nie jest dopuszczony} do wykonywania swojej sekcji krytycznej.
Zatem wykonanie sekcji krytycznych przez procesy podlega wzajemnemu wykluczaniu (wzajemnemu wyłączaniu: ang. mutual exclusion) w czasie.
Problem sekcji krytycznej polega na skonstruowaniu protokołu, który mógłby posłużyć do organizowania współpracy procesów.
Każdy proces musi prosić o pozwolenie na wejście do swojej sekcji krytycznej


\section{EKK\_IT1A\_W06}
\textbf{233. Strategia, która pozwala procesowi, który spełnia warunki wykonywaloności być chwilowo zawieszony jest nazwana:}

\vspace{0.4cm}

Odpowiedź: first come first servived (Prawda. Mnie się wydaje, że wszystkie, bo niezależnie od strategii/algorytmu zawsze trzeba jakiś proces przepuścić ablo być przepuszonym(więc ktoś inny czeka))


Wyjaśnienie:Gdy tylko procesor zaczyna być bezczynny, system operacyjny musi wybrać do wykonywania jakiś proces z kolejki procesów gotowych.
Wyboru doko-nuje planista krótkoterminowy, czyli planista przydziału procesora

Algorytmy planowania:
\begin{itemize}
	\item FCFS (FIFO) First Come First Served
	\item planowanie pritytetowe - każdemu procesowi nadajemy priorytet. Po czym przydzielamy czas temu, kto ma najwyższy priorytet, jeśli mają taki sam są obługiwane jak w FCFS
	\item SJF (Shortest Job First) - szczególny przypadek planowania priorytetowego; najpierw ten kto chce najmniej czasu procesora
	\item planowanie rotacyjne (RR - Round-robin, zwane też karuzlelowym) - taki FCFS tylko z wywłaszczeniem - każdy proces ma swój określony od górnie i równy dla wszystkich czas
	\item wielopoziomowe planowanie kolejek - procesy są przydzielane (na stałe) do kilku kolejek (grupowane razem są np: procesy interakcyjne, drugoplanowe itd).
	Każda kolejka ma swój algorytm przydzielania czasu. Kolejki mają swoje priorytety. Najpierw wykonuje się procesy z kolejek o wyższych priorytetach
	\item planowanie wielopoziomowe kolejek ze sprzężeniem zwrotnym - jak powyżej, ale jeśli proces potrzebuje może zmienić kolejkę (bo za długo już czeka, bo za dużo zjada procesora itd)


\end{itemize}

\section{EKK\_IT1A\_W06}
\textbf{234. Stan uprzywilejowany jest...}

\vspace{0.4cm}

Odpowiedź: dopuszczalny tylko do wykonywania instrukcji systemu operacyjnego (Nie jestem pewna co autor miał na myśli- jeśli, że nic poza tymi intrukcjami nie można FAŁSZ, jeśli,
 że tylko stan uprzywilejowany umożliwia wykownywanie tych instrukcji to PRAWDA )

Wyjaśnienie:
Tryby pracy: użytkownika i systemu == uprzywilejowany == nadzorcy == monitora
Gdy system operacyjny przejmuje kontrolę to jesteśmy w trybie uprzywilejowanym, a gdy apka użytkownika to w trybie użytkownika


Stan uprzywilejowany to taki w którym możemy wykonywać instrukcje uprzywilejowane, a cechy tych instrukcji to
\begin{itemize}
	\item stworzone by chronić
	\item niedostępne dla aplikacji użytkowanika
	\item np: zmiany w rejestrach, operacje wejścia/wyjścia, obługa przerwań
\end{itemize}


\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{235. Komunikacja między procesami...}

\vspace{0.4cm}

Odpowiedź: umożliwia systemom synchronizację ich aktywności (PRAWDA)

Wyjaśnienie:
Komunikacja międzyprocesowa umożliwia procesom łączność i synchronizowanie działań bez dzielenia tej samej przestrzeni adresowej.
Szczególnie przydatna w środowisku rozproszonym.

Komunikację międzyprocesową realizuje się przez system przekazywania komunikatów:
\begin{itemize}
	\item komunikacja bezpośrednia - muszę jawnie nazwać obiorcę/nadawcę, między każdą parą procesów istnieje jedno łącze
	\item komunikacja pośrednia - używam skrzynek pocztowych/potrów, procesy mogą pobierać/nadawać dane z tego abstrakcyjnego miejsca
	\item komunikacja symetryczna lub asymetryczna
	\item buforowanie automatyczne lub jawne
	\item wysyłanie na zasadzie tworzenia kopii lub odsyłaczy
	\item komunikaty stałej długoiści lub zmiennej długośco
\end{itemize}


\section{EKK\_IT1A\_W06}
\textbf{236. Przy organizacji pamięci wirtualnej dynamiczna translacja adresu}

\vspace{0.4cm}

Odpowiedź: wymaga sprzętowego wspomagania systemu stronnicowania (FAŁSZ, o ile dobrze zrozumiałam pytanie)

Wyjaśnienie:  Pamięć wirtualna jest najczęściej implementowana w formie stronicowania na żądanie.  Można ją także zrealizować w systemie segmentacji.
 W kilku systemach użyto schematu stronicowanego segmentowania, w którym segmenty są podzielone na strony.

 W celu lepszego wykorzystania obszaru pamięci możemy zastosować ładowanie dynamiczne.
 Przy ładowaniu dynamicznym podprogram nie jest wprowadzany do pamięci dopóty, dopóki nie zostanie wywołany.
 Zatem zaletą jest to, że nigdy nie załądujemy podprogramu, którego się nie używa.
Ładowanie dynamiczne nie wymaga specjalnego wsparcia ze strony systemu operacyjnego.


\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{Inicjalna wartość semafora uogólnionego implementującego sekcję krytyczną wynosi}

\vspace{0.4cm}

Odpowiedź: Dowolna liczba dodatnia (brak 100 pewności -- patrz wyjaśnienie)

Semafor - mechanizm synchronizacji procesów, został zaproponowaniy przez Dijkstrę.
Semafor jest zmienną całkowitą, która z logicznego punktu widzenia (z punktu widzenia aplikacji) przyjmuje wartości nieujemne (>0) lub — w przypadku semaforów binarnych — logiczne. Zmienna semaforowa musi mieć nadaną początkową wartość (oczywiście nieujemną).

Semafor uogólniony (semafor zliczający) można zwiększać lub zmniejszać o dowolną podaną wartość pod warunkiem, że w wyniku zmniejszenia zmienna semaforowa nie osiągnie wartości ujemnej. Jeśli zatem wartość parametru, o którą ma być zmniejszona zmienna semaforowa jest większa od wartości tej zmiennej, następuje zablokowanie procesu.

Wyjaśnienie: W początkowej sytuacji żaden proces nie jest w sekcji krytycznej ,więc semafor musi “dać się zmniejszyć” pozwalając na wejście do sekcji krytycznej, czyli musi być na pewno różny od 0. Jeżeli mówimy o semaforze uogólnionym to zasadniczo dowolna całkowita liczba dodatnia może być wartością początkową, jeżeli tylko zaimplementujemy tą sekcję krytyczną w ten sposób aby opuszczała i podnosiła semafor o tą stałą wartość początkową to to będzie działać.


\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{Proces transferowania danych, które mają być docelowo wyprowadzone na urządzenie peryferyjne do przestrzeni pamięci pomocniczej i~transferowanie ich na to urządzenie w~dogodniejszym czasie nosi nazwę}

\vspace{0.4cm}

Odpowiedź: buforowanie / przechowywanie podręczne (może cachowanie?)

Szczegóły: http://smurf.mimuw.edu.pl/node/919
System operacyjny np. pisząc na dysk nie zapisuje od razu wszystkiego “twardo” na dysk, tylko trzyma to w buforach, które są transferowane na dysk w późniejszym czasie. Pozwala to na szybsze zakończenie operacji IO.

\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{Problem producent-konsument może być rozwiązany przy pomocy}

\vspace{0.4cm}
\begin{itemize}
	\item semafory
	\item monitory
	\item mutexy
	\item pamięć dzielona
	\item zmienne warunkowe
	\item bariery
	\item wirująca blokada
\end{itemize}

Bariera jest to punkt synchronizacyjny dla grupy procesów, do którego musza dojść wszystkie procesy zanim będą mogły kontynuować.

Wirująca blokada (spinlock) jest to blokada polegająca na ciągłym sprawdzaniu locka w pętli - działa jak jakiś mutex albo coś, przy czym zajmuje czas procesora i dlatego jest niewydajny.

Problem producenta i konsumenta to klasyczny informatyczny problem synchronizacji. W problemie występują dwa rodzaje procesów: producent i konsument, którzy dzielą wspólny zasób - bufor dla produkowanych (konsumowanych) jednostek. Zadaniem producenta jest wytworzenie produktu, umieszczenie go w buforze i rozpoczęcie pracy od nowa. W tym samym czasie konsument ma pobrać produkt z bufora. Problemem jest taka synchronizacja procesów, żeby producent nie dodawał nowych jednostek gdy bufor jest pełny, a konsument nie pobierał gdy bufor jest pusty.
Rozwiązaniem dla producenta jest uśpienie procesu w momencie gdy bufor jest pełny. Pierwszy konsument, który pobierze element z bufora budzi proces producenta, który uzupełnia bufor. W analogiczny sposób usypiany jest konsument próbujący pobrać z pustego bufora. Pierwszy producent, po dodaniu nowego produktu umożliwi dalsze działanie konsumentowi. 


\section{EKK\_IT1A\_W06}
\textbf{Centralny Procesor, po otrzymaniu informacji o przerwaniu z urządzenia wejścia/wyjścia}

\vspace{0.4cm}

Nie mogę podać konkretnej odpowiedzi, bo kto wie co autor miał na myśli. Warto przeczytać:
https://pl.wikipedia.org/wiki/Przerwanie\#Przerwania\_sprz.C4.99towe
http://studianet.pl/kursy/proki/procesor/przerwania.htm
http://students.mimuw.edu.pl/SO/Linux/Temat07/Linux714.html
http://students.mimuw.edu.pl/SO/LabLinux/WEJSCIE-WYJSCIE/PODTEMAT\_1/index2.html



\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{Który z problemów rozwiązuje zaproponowany przez Dijkstrę algorytm Bankiera}

\vspace{0.4cm}

unikania zakleszczenia (deadlock avoidance)

Algorytm bankiera:
Nazwę zawdzięcza temu, że mógłby on posłużyć w systemie bankowym do zagwarantowania, iż bank nigdy nie zainwestuje gotówki w sposób, który uniemożliwiłby mu zaspokojenie wymagań wszystkich jego klientów.
Gdy proces wchodzi do systemu, wówczas musi zadeklarować maksymalną liczbę egzemplarzy każdego typu zasobu, które będą mu potrzebne.
Liczba ta nie może przekroczyć ogólnej liczby zasobów w systemie. 
Kiedy użytkownik zamawia zbiór zasobów, wtedy system musi określić, czy ich przydzielenie pozostawi system w stanie bezpiecznym. Jeśli tak, to zasoby zostaną przydzielone; w przeciwnym razie proces będzie musiał poczekać, aż inne procesy zwolnią wystarczającą ilość zasobów.

\textbf{Algorytm bankiera}

    Dla zasobów wielokrotnych. Każdy proces musi a priori złożyć maksymalne zapotrzebowanie na zasoby. Proces żądający zasobu być może będzie musiał czekać, mimo że zasób jest dotępny.     Gdy proces dostanie wszystkie potrzebne zasoby, to zwróci je w skończonym czasie. Koszt stwierdzania, czy stan jest bezpieczny: m x n2.

\textbf{Szczegóły algorytmu bankiera}

Struktury danych:

Dostępne: wektor o długości m, określający liczbę dostępnych zasobów każdego typu. Dostępne[j]=k oznacza, że jest dostępnych k egzemplarzy zasobu typu Zj.
Maksymalne: Macierz o wymiarach n x m, definiująca maksymalne żądania każdego procesu. Jeśli Maksymalne[i,j]=k, to proces Pi może zamówić co najwyżej k egzemplarzy zasobu typu Zj.
Przydzielone: Macierz o wymiarach n x m, definiująca liczbę zasobów poszczególnych typów, przydzielonych do każdego z procesów. Gdy Przydzielone[i,j]=k, wówczas proces Pi ma przydzielonych k egzemplarzy zasobu typu Zj.
Potrzebne: Macierz o wymiarach n x m, przechowująca pozostałe do spełnienia zamówienia każdego z procesów. Element Potrzebne[i,j]=k oznacza, że do zakończenia swojej pracy proces Pi może jeszcze potrzebować k dodatkowych egzemplarzy zasobu typu Zj. Zauważmy, że

       Potrzebne[i,j] = Maksymalne[i,j] - Przydzielone[i,j]



\section{EKK\_IT1A\_W06}
\textbf{Jeżeli wirtualny adres w programie jest 16 bitowy i rozmiar strony jest 0,5 K to możemy maksymalnie zaadresować następującą liczbę stron:}

\vspace{0.4cm}

$$ 2^{16} = 65536 $$ - tyle komórek pamięci możemy zaadresować
$$ 65536 / 512 = 128 $$ - tyle stron istnieje w danej sytuacji



\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{System operacyjny jest}

\vspace{0.4cm}
Ciężko określić konkretne - poprawne - odpowiedzi, dlatego podaję kilka linków, które warto przeczytać (wydaje się krótko i na temat):
http://wazniak.mimuw.edu.pl/images/3/38/Sop\_01\_wyk\_1.0.pdf 
https://pl.wikipedia.org/wiki/System\_operacyjny
http://zsel.edu.pl/dydaktyka/cplus/zadania\_so.htm 


\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{W systemie zarządzania pamięcią rejestry graniczne DATUM i LIMIT}

\vspace{0.4cm}

\begin{itemize}
	\item są używane dla ochrony kodu programu
	\item LIMIT - służy do zarządzania ochroną pamięci, specyfikuje zakres pamięci, zawiera zakres adresów logicznych, definiuje logiczną przestrzeń adresową
	\item DATUM - służy do zarządzania ochroną pamięci, specyfikuje pierwszy dostępny adres pamięci
\end{itemize}


\section{EKK\_IT1A\_W09,EKK\_IT1A\_W06}
\textbf{Jeżeli system operacyjny chce wykonywać więcej niż jeden program w danym momencie czasu to musi}

\vspace{0.4cm}

Pytanie bardzo szerokie, ciężko wskazać krótką odpowiedź. Polecam przeczytać:
\url{https://pl.wikipedia.org/wiki/Wielozadaniowo%C5%9B%C4%87}
\url{https://en.wikipedia.org/wiki/Computer\_multitasking} (to się wydaje dość sensowne)
http://wazniak.mimuw.edu.pl/images/a/ab/Sop\_11\_wyk\_1.0.pdf 


\section{EKK\_IT1A\_W06}
\textbf{Szyfrowanie kluczem publicznym w szyfrowaniu asymetrycznym}

\vspace{0.4cm}
wiadomość zaszyfrowana za pomocą klucza publicznego może być odszyfrowana tylko za pomocą klucza prywatnego

Odbiorca za pomocą specjalnego algorytmu (szyfru) asymetrycznego (np. RSA, ElGamal, DSA, ECC, Diffy-Hellman, Cramer-Shoup) generuje oba klucze. Klucz publiczny odbiorca przekazuję nadawcy. Ponieważ jest on publiczny odbiorca nie musi martwić się o jego przekazanie nadawcy - może to zrobić np. za pomocą Internetu, umieścić na stronie czy forum. To że wszyscy mogą zdobyć ten klucz nie stanowi żadnego problemu.
Nadawca korzystając z przekazanego mu klucza publicznego szyfruje wiadomość.
Odbiorca odszyfrowuje wiadomość za pomocą prywatnego klucza.

Jeżeli ktoś postronny zdobył ten klucz publiczny również może zaszyfrować wiadomość. Pamiętajmy jednak że tylko odbiorca dysponuje kluczem prywatnym, a w szyfrowaniu asymetrycznym wiadomość zaszyfrowana za pomocą klucza publicznego może być odszyfrowana tylko za pomocą klucza prywatnego! 

Algorytm asymetryczny, nazywany też algorytmem z kluczem publicznym bądź jawnym, musi spełniać poniższe kryteria:    
klucze występują w parach: jeden klucz do szyfrowania i jeden do deszyfrowania,
opublikowanie jednego z kluczy w parze nie zdradza drugiego klucza, nawet przy wykorzystaniu złożonych obliczeń,
zwykle jeden klucz z pary jest powszechnie dostępny, może pełnić rolę klucza szyfrującego lub deszyfrującego, jest on nazywany kluczem publicznym. Drugi klucz jest trzymany w tajemnicy przez jego posiadacza – jest to klucz prywatny.

Klucz publiczny używany jest do zaszyfrowania informacji, klucz prywatny do jej odczytu. Ponieważ klucz prywatny jest w wyłącznym posiadaniu adresata informacji, tylko on może ją odczytać. Natomiast klucz publiczny jest udostępniony każdemu, kto zechce zaszyfrować wiadomość.
Ponieważ kryptografia asymetryczna jest o wiele wolniejsza od symetrycznej, prawie nigdy nie szyfruje się wiadomości za pomocą kryptosystemów asymetrycznych. Zamiast tego szyfruje się jedynie klucz jakiegoś szyfru symetrycznego, takiego jak np. AES. Takie protokoły, łączące elementy kryptografii symetrycznej i asymetrycznej, nazywa się hybrydowymi.




\section{EKK\_IT1A\_W06}
\textbf{Buforowanie plików realizowane jest w celu}

\vspace{0.4cm}

Zwiększenia wydajności komputera, poprzez zmniejszenie tzw. "przestojów" procesora
zmniejszenie czasu oczekiwania na operację wejścia lub wyjścia
Oszczędność sprzetu poprzez niewykonywanie operacji zapisu (nie jakiś główny powód, ale na pewno zaleta)

Buforowanie – technologia polegająca na stosowaniu buforów programowych lub sprzętowych, wykorzystywana najczęściej w celu wyrównania różnic prędkości przesyłania danych między różnymi urządzeniami. Działa on zazwyczaj wykorzystując zasadę FIFO.
Można wykorzystywać bufory o:
zerowej pojemności (bufor jest tylko przekaźnikiem komunikatów),
ograniczonej pojemności,
nieograniczonej pojemności.
